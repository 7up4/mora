= nested_form_for book, remote: true, authenticity_token: true do |f|
  - if book.errors.any?
    #error_explanation
      %h2
        = pluralize(book.errors.count, "error")
        prohibited this book from being saved:
      %ul
        - book.errors.full_messages.each do |message|
          %li= message
  .field#date_of_publication
    = f.label :date_of_publication
    = f.text_field :date_of_publication, class: 'datepicker'
  - if @book.genres.exists?
    .field#genres
    = f.label :genres
    = @book.genres.collect{|g| g.genre_name}.join(', ')
  .field#volume
    = f.label :volume
    = f.number_field :volume, min:0
  .field#language
    = f.label :language
    = f.select :language, ApplicationRecord::LANGUAGES, include_blank: true
  - if action_name != 'edit'
    .field#book_file
      = f.label :book_file
      = book.book_file_url.to_s if book.book_file?
      = f.file_field :book_file
      = f.hidden_field :book_file_cache
  -# .field#cover
  -#   = f.label :cover
  -#   = book.cover_url.to_s if book.cover?
  -#   = f.file_field :cover
  -#   = f.hidden_field :cover_cache
  .field#genres
    = f.label :genres
    = f.select :genre_ids, Genre.all.collect{|g| [g.genre_name, g.id]}, {}, multiple: true
  .field#authors
    = f.label :authors
    = f.select :author_ids, Author.all.select{|a| !a.books.exists?(@book.id)}.collect{|a| [a.first_name+' '+a.last_name, a.id]}, {}, multiple: true
  .field#publishers
    = f.label :publishers
    = f.select :publisher_ids, Publisher.all.select{|p| !p.books.exists?(@book.id)}.collect{|p| [p.publisher_name, p.id]}, {}, multiple: true
  = render 'author_fields', book: f
  = render 'publisher_fields', book: f
  .actions
    = f.submit
